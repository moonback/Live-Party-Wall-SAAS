-- ==========================================
-- LIVE PARTY WALL - MIGRATION COMPLÈTE SUPABASE
-- ==========================================
-- Ce fichier contient TOUTES les migrations nécessaires
-- pour initialiser complètement la base de données Supabase
-- pour l'application Live Party Wall (SaaS multi-événements).
--
-- Date: 2026-01-15
-- ==========================================

-- ==========================================
-- 1. EXTENSIONS
-- ==========================================

CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- ==========================================
-- 2. TABLE EVENTS (Base pour SaaS multi-événements)
-- ==========================================

CREATE TABLE IF NOT EXISTS public.events (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    slug TEXT UNIQUE NOT NULL,
    name TEXT NOT NULL,
    description TEXT,
    owner_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ DEFAULT now(),
    is_active BOOLEAN DEFAULT true
);

CREATE INDEX IF NOT EXISTS idx_events_slug ON public.events(slug);
CREATE INDEX IF NOT EXISTS idx_events_owner_id ON public.events(owner_id);
CREATE INDEX IF NOT EXISTS idx_events_is_active ON public.events(is_active);

ALTER TABLE public.events ENABLE ROW LEVEL SECURITY;

-- ==========================================
-- 3. TABLE EVENT_ORGANIZERS
-- ==========================================

CREATE TABLE IF NOT EXISTS public.event_organizers (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    event_id UUID REFERENCES public.events(id) ON DELETE CASCADE NOT NULL,
    user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE NOT NULL,
    role TEXT NOT NULL DEFAULT 'organizer',
    created_at TIMESTAMPTZ DEFAULT now(),
    UNIQUE(event_id, user_id),
    CHECK (role IN ('owner', 'organizer', 'viewer'))
);

CREATE INDEX IF NOT EXISTS idx_event_organizers_event_id ON public.event_organizers(event_id);
CREATE INDEX IF NOT EXISTS idx_event_organizers_user_id ON public.event_organizers(user_id);
CREATE INDEX IF NOT EXISTS idx_event_organizers_role ON public.event_organizers(role);

ALTER TABLE public.event_organizers ENABLE ROW LEVEL SECURITY;

-- ==========================================
-- 4. TABLE PHOTOS (Base)
-- ==========================================

CREATE TABLE IF NOT EXISTS public.photos (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    url TEXT NOT NULL,
    caption TEXT,
    author TEXT,
    created_at TIMESTAMPTZ DEFAULT now(),
    type TEXT DEFAULT 'photo' NOT NULL,
    duration NUMERIC,
    likes_count INTEGER DEFAULT 0,
    tags JSONB DEFAULT NULL,
    event_id UUID REFERENCES public.events(id) ON DELETE CASCADE
);

-- Contrainte pour le type
DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM pg_constraint 
        WHERE conname = 'photos_type_check' 
        AND conrelid = 'public.photos'::regclass
    ) THEN
        ALTER TABLE public.photos
            ADD CONSTRAINT photos_type_check 
            CHECK (type IN ('photo', 'video'));
    END IF;
END $$;

ALTER TABLE public.photos ENABLE ROW LEVEL SECURITY;

CREATE INDEX IF NOT EXISTS idx_photos_created_at ON public.photos(created_at DESC);
CREATE INDEX IF NOT EXISTS idx_photos_type ON public.photos(type);
CREATE INDEX IF NOT EXISTS idx_photos_author ON public.photos(author);
CREATE INDEX IF NOT EXISTS idx_photos_event_id ON public.photos(event_id);
CREATE INDEX IF NOT EXISTS idx_photos_tags_gin ON public.photos USING GIN (tags);

COMMENT ON COLUMN public.photos.type IS 'Type de média: photo ou video';
COMMENT ON COLUMN public.photos.duration IS 'Durée en secondes (pour les vidéos uniquement)';
COMMENT ON COLUMN public.photos.tags IS 'Tags suggérés par l''IA (tableau JSON de strings, ex: ["sourire", "groupe", "danse", "fête"])';

-- ==========================================
-- 5. TABLE EVENT_SETTINGS
-- ==========================================

CREATE TABLE IF NOT EXISTS public.event_settings (
    id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    event_id UUID REFERENCES public.events(id) ON DELETE CASCADE UNIQUE,
    event_title TEXT NOT NULL DEFAULT 'Party Wall',
    event_subtitle TEXT NOT NULL DEFAULT 'Live',
    scroll_speed TEXT NOT NULL DEFAULT 'normal',
    slide_transition TEXT NOT NULL DEFAULT 'fade',
    decorative_frame_enabled BOOLEAN NOT NULL DEFAULT false,
    decorative_frame_url TEXT,
    caption_generation_enabled BOOLEAN NOT NULL DEFAULT true,
    content_moderation_enabled BOOLEAN NOT NULL DEFAULT true,
    video_capture_enabled BOOLEAN NOT NULL DEFAULT true,
    collage_mode_enabled BOOLEAN NOT NULL DEFAULT true,
    stats_enabled BOOLEAN NOT NULL DEFAULT true,
    find_me_enabled BOOLEAN NOT NULL DEFAULT true,
    ar_scene_enabled BOOLEAN NOT NULL DEFAULT true,
    battle_mode_enabled BOOLEAN NOT NULL DEFAULT true,
    auto_battles_enabled BOOLEAN NOT NULL DEFAULT false,
    tags_generation_enabled BOOLEAN NOT NULL DEFAULT true,
    event_context TEXT,
    alert_text TEXT,
    background_desktop_url TEXT,
    background_mobile_url TEXT,
    created_at TIMESTAMPTZ DEFAULT timezone('utc'::text, now()) NOT NULL,
    updated_at TIMESTAMPTZ DEFAULT timezone('utc'::text, now()) NOT NULL
);

CREATE INDEX IF NOT EXISTS idx_event_settings_event_id ON public.event_settings(event_id);

ALTER TABLE public.event_settings ENABLE ROW LEVEL SECURITY;

COMMENT ON COLUMN public.event_settings.battle_mode_enabled IS 'Active ou désactive le mode battle (création et affichage des battles entre photos)';
COMMENT ON COLUMN public.event_settings.stats_enabled IS 'Active ou désactive la page de statistiques et le lien d''accès sur la page d''accueil';
COMMENT ON COLUMN public.event_settings.collage_mode_enabled IS 'Active ou désactive la fonctionnalité de mode collage pour les utilisateurs';
COMMENT ON COLUMN public.event_settings.video_capture_enabled IS 'Active ou désactive la fonctionnalité de capture vidéo pour les utilisateurs';
COMMENT ON COLUMN public.event_settings.event_context IS 'Contexte de la soirée/événement utilisé pour personnaliser les légendes générées par IA';
COMMENT ON COLUMN public.event_settings.alert_text IS 'Texte d''alerte affiché en grand au-dessus des photos sur le mur pour signaler quelque chose aux invités';
COMMENT ON COLUMN public.event_settings.tags_generation_enabled IS 'Active ou désactive la génération de tags par l''IA pour les photos';
COMMENT ON TABLE public.event_settings IS 'Configuration de l''événement. Les mises à jour sont diffusées en temps réel via Supabase Realtime pour synchroniser tous les clients.';

-- ==========================================
-- 6. TABLE LIKES
-- ==========================================

CREATE TABLE IF NOT EXISTS public.likes (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    photo_id UUID REFERENCES public.photos(id) ON DELETE CASCADE NOT NULL,
    user_identifier TEXT NOT NULL,
    created_at TIMESTAMPTZ DEFAULT now(),
    UNIQUE(photo_id, user_identifier)
);

ALTER TABLE public.likes ENABLE ROW LEVEL SECURITY;

CREATE INDEX IF NOT EXISTS idx_likes_photo_id ON public.likes(photo_id);
CREATE INDEX IF NOT EXISTS idx_likes_user_identifier ON public.likes(user_identifier);
CREATE INDEX IF NOT EXISTS idx_likes_photo_user ON public.likes(photo_id, user_identifier);

-- ==========================================
-- 7. TABLE REACTIONS
-- ==========================================

CREATE TABLE IF NOT EXISTS public.reactions (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    photo_id UUID REFERENCES public.photos(id) ON DELETE CASCADE NOT NULL,
    user_identifier TEXT NOT NULL,
    reaction_type TEXT NOT NULL,
    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ DEFAULT now(),
    UNIQUE(photo_id, user_identifier)
);

ALTER TABLE public.reactions ENABLE ROW LEVEL SECURITY;

CREATE INDEX IF NOT EXISTS idx_reactions_photo_id ON public.reactions(photo_id);
CREATE INDEX IF NOT EXISTS idx_reactions_user_identifier ON public.reactions(user_identifier);
CREATE INDEX IF NOT EXISTS idx_reactions_photo_user ON public.reactions(photo_id, user_identifier);

-- ==========================================
-- 8. TABLE GUESTS
-- ==========================================

CREATE TABLE IF NOT EXISTS public.guests (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    name TEXT NOT NULL,
    avatar_url TEXT NOT NULL,
    event_id UUID REFERENCES public.events(id) ON DELETE CASCADE,
    created_at TIMESTAMPTZ DEFAULT now() NOT NULL,
    updated_at TIMESTAMPTZ DEFAULT now() NOT NULL
);

CREATE INDEX IF NOT EXISTS idx_guests_name ON public.guests(name);
CREATE INDEX IF NOT EXISTS idx_guests_created_at ON public.guests(created_at);
CREATE INDEX IF NOT EXISTS idx_guests_event_id ON public.guests(event_id);

ALTER TABLE public.guests ENABLE ROW LEVEL SECURITY;

-- ==========================================
-- 9. TABLE BLOCKED_GUESTS
-- ==========================================

CREATE TABLE IF NOT EXISTS public.blocked_guests (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    name TEXT NOT NULL,
    event_id UUID REFERENCES public.events(id) ON DELETE CASCADE,
    blocked_at TIMESTAMPTZ DEFAULT now() NOT NULL,
    expires_at TIMESTAMPTZ NOT NULL,
    created_at TIMESTAMPTZ DEFAULT now() NOT NULL
);

CREATE INDEX IF NOT EXISTS idx_blocked_guests_name ON public.blocked_guests(name);
CREATE INDEX IF NOT EXISTS idx_blocked_guests_expires_at ON public.blocked_guests(expires_at);
CREATE INDEX IF NOT EXISTS idx_blocked_guests_event_id ON public.blocked_guests(event_id);

ALTER TABLE public.blocked_guests ENABLE ROW LEVEL SECURITY;

-- ==========================================
-- 10. TABLE PHOTO_BATTLES
-- ==========================================

CREATE TABLE IF NOT EXISTS public.photo_battles (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    photo1_id UUID REFERENCES public.photos(id) ON DELETE CASCADE NOT NULL,
    photo2_id UUID REFERENCES public.photos(id) ON DELETE CASCADE NOT NULL,
    event_id UUID REFERENCES public.events(id) ON DELETE CASCADE,
    status TEXT NOT NULL DEFAULT 'active',
    winner_id UUID REFERENCES public.photos(id) ON DELETE SET NULL,
    votes1_count INTEGER NOT NULL DEFAULT 0,
    votes2_count INTEGER NOT NULL DEFAULT 0,
    created_at TIMESTAMPTZ DEFAULT now(),
    finished_at TIMESTAMPTZ,
    expires_at TIMESTAMPTZ,
    CHECK (photo1_id != photo2_id),
    CHECK (status IN ('active', 'finished', 'cancelled'))
);

CREATE TABLE IF NOT EXISTS public.battle_votes (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    battle_id UUID REFERENCES public.photo_battles(id) ON DELETE CASCADE NOT NULL,
    user_identifier TEXT NOT NULL,
    voted_for_photo_id UUID REFERENCES public.photos(id) ON DELETE CASCADE NOT NULL,
    created_at TIMESTAMPTZ DEFAULT now(),
    UNIQUE(battle_id, user_identifier)
);

ALTER TABLE public.photo_battles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.battle_votes ENABLE ROW LEVEL SECURITY;

CREATE INDEX IF NOT EXISTS idx_battles_status ON public.photo_battles(status);
CREATE INDEX IF NOT EXISTS idx_battles_created_at ON public.photo_battles(created_at DESC);
CREATE INDEX IF NOT EXISTS idx_battles_expires_at ON public.photo_battles(expires_at) WHERE expires_at IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_photo_battles_event_id ON public.photo_battles(event_id);
CREATE INDEX IF NOT EXISTS idx_battle_votes_battle_id ON public.battle_votes(battle_id);
CREATE INDEX IF NOT EXISTS idx_battle_votes_user_identifier ON public.battle_votes(user_identifier);
CREATE INDEX IF NOT EXISTS idx_battle_votes_battle_user ON public.battle_votes(battle_id, user_identifier);

-- ==========================================
-- 11. STORAGE BUCKETS
-- ==========================================

-- Bucket party-photos
INSERT INTO storage.buckets (id, name, public)
VALUES ('party-photos', 'party-photos', true)
ON CONFLICT (id) DO UPDATE SET public = true;

-- Bucket party-frames
INSERT INTO storage.buckets (id, name, public)
VALUES ('party-frames', 'party-frames', true)
ON CONFLICT (id) DO UPDATE SET public = true;

-- Bucket party-avatars
INSERT INTO storage.buckets (id, name, public)
VALUES ('party-avatars', 'party-avatars', true)
ON CONFLICT (id) DO UPDATE SET public = true;

-- Bucket party-backgrounds
INSERT INTO storage.buckets (id, name, public)
VALUES ('party-backgrounds', 'party-backgrounds', true)
ON CONFLICT (id) DO UPDATE SET public = true;

-- ==========================================
-- 12. POLITIQUES STORAGE
-- ==========================================

-- Politiques Storage pour party-photos
DROP POLICY IF EXISTS "Public Access Bucket" ON storage.objects;
CREATE POLICY "Public Access Bucket"
ON storage.objects FOR SELECT
TO anon, authenticated
USING (bucket_id = 'party-photos');

DROP POLICY IF EXISTS "Public Upload Bucket" ON storage.objects;
CREATE POLICY "Public Upload Bucket"
ON storage.objects FOR INSERT
TO anon, authenticated
WITH CHECK (bucket_id = 'party-photos');

DROP POLICY IF EXISTS "Admin Delete Storage" ON storage.objects;
CREATE POLICY "Admin Delete Storage"
ON storage.objects FOR DELETE
TO authenticated
USING (bucket_id = 'party-photos');

-- Politiques Storage pour party-frames
DROP POLICY IF EXISTS "Public Access Frames Bucket" ON storage.objects;
CREATE POLICY "Public Access Frames Bucket"
ON storage.objects FOR SELECT
TO anon, authenticated
USING (bucket_id = 'party-frames');

DROP POLICY IF EXISTS "Admin Upload Frames Bucket" ON storage.objects;
CREATE POLICY "Admin Upload Frames Bucket"
ON storage.objects FOR INSERT
TO authenticated
WITH CHECK (bucket_id = 'party-frames' AND auth.role() = 'authenticated');

DROP POLICY IF EXISTS "Admin Update Frames Bucket" ON storage.objects;
CREATE POLICY "Admin Update Frames Bucket"
ON storage.objects FOR UPDATE
TO authenticated
USING (bucket_id = 'party-frames' AND auth.role() = 'authenticated')
WITH CHECK (bucket_id = 'party-frames' AND auth.role() = 'authenticated');

DROP POLICY IF EXISTS "Admin Delete Frames Bucket" ON storage.objects;
CREATE POLICY "Admin Delete Frames Bucket"
ON storage.objects FOR DELETE
TO authenticated
USING (bucket_id = 'party-frames' AND auth.role() = 'authenticated');

-- Politiques Storage pour party-avatars
DROP POLICY IF EXISTS "Public Access Avatars Bucket" ON storage.objects;
CREATE POLICY "Public Access Avatars Bucket"
ON storage.objects FOR SELECT
TO anon, authenticated
USING (bucket_id = 'party-avatars');

DROP POLICY IF EXISTS "Public Upload Avatars Bucket" ON storage.objects;
CREATE POLICY "Public Upload Avatars Bucket"
ON storage.objects FOR INSERT
TO anon, authenticated
WITH CHECK (bucket_id = 'party-avatars');

DROP POLICY IF EXISTS "Public Update Avatars Bucket" ON storage.objects;
CREATE POLICY "Public Update Avatars Bucket"
ON storage.objects FOR UPDATE
TO anon, authenticated
USING (bucket_id = 'party-avatars')
WITH CHECK (bucket_id = 'party-avatars');

DROP POLICY IF EXISTS "Authenticated Delete Avatars Bucket" ON storage.objects;
CREATE POLICY "Authenticated Delete Avatars Bucket"
ON storage.objects FOR DELETE
TO authenticated
USING (bucket_id = 'party-avatars');

-- Politiques Storage pour party-backgrounds
DROP POLICY IF EXISTS "Public Access Backgrounds Bucket" ON storage.objects;
CREATE POLICY "Public Access Backgrounds Bucket"
ON storage.objects FOR SELECT
TO anon, authenticated
USING (bucket_id = 'party-backgrounds');

DROP POLICY IF EXISTS "Admin Upload Backgrounds Bucket" ON storage.objects;
CREATE POLICY "Admin Upload Backgrounds Bucket"
ON storage.objects FOR INSERT
TO authenticated
WITH CHECK (bucket_id = 'party-backgrounds' AND auth.role() = 'authenticated');

DROP POLICY IF EXISTS "Admin Update Backgrounds Bucket" ON storage.objects;
CREATE POLICY "Admin Update Backgrounds Bucket"
ON storage.objects FOR UPDATE
TO authenticated
USING (bucket_id = 'party-backgrounds' AND auth.role() = 'authenticated')
WITH CHECK (bucket_id = 'party-backgrounds' AND auth.role() = 'authenticated');

DROP POLICY IF EXISTS "Admin Delete Backgrounds Bucket" ON storage.objects;
CREATE POLICY "Admin Delete Backgrounds Bucket"
ON storage.objects FOR DELETE
TO authenticated
USING (bucket_id = 'party-backgrounds' AND auth.role() = 'authenticated');

-- ==========================================
-- 13. FONCTION HELPER POUR PERMISSIONS
-- ==========================================

CREATE OR REPLACE FUNCTION public.is_event_organizer(event_uuid UUID, user_uuid UUID)
RETURNS BOOLEAN
LANGUAGE plpgsql
SECURITY DEFINER
STABLE
AS $$
BEGIN
    -- Vérifier si l'utilisateur est owner de l'événement
    IF EXISTS (
        SELECT 1 FROM public.events
        WHERE events.id = event_uuid
        AND events.owner_id = user_uuid
    ) THEN
        RETURN TRUE;
    END IF;

    -- Vérifier si l'utilisateur est dans event_organizers
    IF EXISTS (
        SELECT 1 FROM public.event_organizers
        WHERE event_organizers.event_id = event_uuid
        AND event_organizers.user_id = user_uuid
    ) THEN
        RETURN TRUE;
    END IF;

    RETURN FALSE;
END;
$$;

GRANT EXECUTE ON FUNCTION public.is_event_organizer(UUID, UUID) TO authenticated;

-- ==========================================
-- 14. POLITIQUES RLS POUR EVENTS
-- ==========================================

DROP POLICY IF EXISTS "Public Read Active Events" ON public.events;
CREATE POLICY "Public Read Active Events"
ON public.events FOR SELECT
TO anon, authenticated
USING (is_active = true);

DROP POLICY IF EXISTS "Authenticated Create Events" ON public.events;
CREATE POLICY "Authenticated Create Events"
ON public.events FOR INSERT
TO authenticated
WITH CHECK (
    auth.uid() IS NOT NULL AND
    auth.uid() = owner_id
);

DROP POLICY IF EXISTS "Organizers Update Events" ON public.events;
CREATE POLICY "Organizers Update Events"
ON public.events FOR UPDATE
TO authenticated
USING (
    owner_id = auth.uid()
    OR
    public.is_event_organizer(id, auth.uid())
)
WITH CHECK (
    owner_id = auth.uid()
    OR
    public.is_event_organizer(id, auth.uid())
);

DROP POLICY IF EXISTS "Owners Delete Events" ON public.events;
CREATE POLICY "Owners Delete Events"
ON public.events FOR DELETE
TO authenticated
USING (owner_id = auth.uid());

-- ==========================================
-- 15. POLITIQUES RLS POUR EVENT_ORGANIZERS
-- ==========================================

DROP POLICY IF EXISTS "Organizers Read Event Organizers" ON public.event_organizers;
CREATE POLICY "Organizers Read Event Organizers"
ON public.event_organizers FOR SELECT
TO authenticated
USING (
    EXISTS (
        SELECT 1 FROM public.events
        WHERE events.id = event_organizers.event_id
        AND events.owner_id = auth.uid()
    )
    OR
    event_organizers.user_id = auth.uid()
);

DROP POLICY IF EXISTS "Owners Insert Event Organizers" ON public.event_organizers;
CREATE POLICY "Owners Insert Event Organizers"
ON public.event_organizers FOR INSERT
TO authenticated
WITH CHECK (
    EXISTS (
        SELECT 1 FROM public.events
        WHERE events.id = event_organizers.event_id
        AND events.owner_id = auth.uid()
    )
);

DROP POLICY IF EXISTS "Owners Update Event Organizers" ON public.event_organizers;
CREATE POLICY "Owners Update Event Organizers"
ON public.event_organizers FOR UPDATE
TO authenticated
USING (
    EXISTS (
        SELECT 1 FROM public.events
        WHERE events.id = event_organizers.event_id
        AND events.owner_id = auth.uid()
    )
);

DROP POLICY IF EXISTS "Owners Delete Event Organizers" ON public.event_organizers;
CREATE POLICY "Owners Delete Event Organizers"
ON public.event_organizers FOR DELETE
TO authenticated
USING (
    EXISTS (
        SELECT 1 FROM public.events
        WHERE events.id = event_organizers.event_id
        AND events.owner_id = auth.uid()
    )
);

-- ==========================================
-- 16. POLITIQUES RLS POUR PHOTOS
-- ==========================================

DROP POLICY IF EXISTS "Public Read Photos" ON public.photos;
DROP POLICY IF EXISTS "Public Read Photos By Event" ON public.photos;
CREATE POLICY "Public Read Photos By Event"
ON public.photos FOR SELECT
TO anon, authenticated
USING (
    event_id IS NOT NULL AND
    EXISTS (SELECT 1 FROM public.events WHERE events.id = photos.event_id AND events.is_active = true)
);

DROP POLICY IF EXISTS "Public Insert Photos" ON public.photos;
DROP POLICY IF EXISTS "Public Insert Photos By Event" ON public.photos;
CREATE POLICY "Public Insert Photos By Event"
ON public.photos FOR INSERT
TO anon, authenticated
WITH CHECK (
    event_id IS NOT NULL AND
    EXISTS (SELECT 1 FROM public.events WHERE events.id = photos.event_id AND events.is_active = true)
);

DROP POLICY IF EXISTS "Admin Delete Photos" ON public.photos;
DROP POLICY IF EXISTS "Organizers Delete Photos" ON public.photos;
CREATE POLICY "Organizers Delete Photos"
ON public.photos FOR DELETE
TO authenticated
USING (
    public.is_event_organizer(photos.event_id, auth.uid())
);

-- ==========================================
-- 17. POLITIQUES RLS POUR EVENT_SETTINGS
-- ==========================================

DROP POLICY IF EXISTS "Public settings access" ON public.event_settings;
DROP POLICY IF EXISTS "Public Read Settings By Event" ON public.event_settings;
CREATE POLICY "Public Read Settings By Event"
ON public.event_settings FOR SELECT
TO anon, authenticated
USING (
    event_id IS NOT NULL AND
    EXISTS (SELECT 1 FROM public.events WHERE events.id = event_settings.event_id AND events.is_active = true)
);

DROP POLICY IF EXISTS "Admin update settings" ON public.event_settings;
DROP POLICY IF EXISTS "Organizers Update Settings By Event" ON public.event_settings;
CREATE POLICY "Organizers Update Settings By Event"
ON public.event_settings FOR UPDATE
TO authenticated
USING (
    event_id IS NOT NULL AND
    public.is_event_organizer(event_settings.event_id, auth.uid())
);

DROP POLICY IF EXISTS "Admin insert settings" ON public.event_settings;
DROP POLICY IF EXISTS "Organizers Insert Settings By Event" ON public.event_settings;
CREATE POLICY "Organizers Insert Settings By Event"
ON public.event_settings FOR INSERT
TO authenticated
WITH CHECK (
    event_id IS NOT NULL AND
    public.is_event_organizer(event_settings.event_id, auth.uid())
);

-- ==========================================
-- 18. POLITIQUES RLS POUR LIKES
-- ==========================================

DROP POLICY IF EXISTS "Public Read Likes" ON public.likes;
CREATE POLICY "Public Read Likes"
ON public.likes FOR SELECT
TO anon, authenticated
USING (true);

DROP POLICY IF EXISTS "Public Insert Likes" ON public.likes;
CREATE POLICY "Public Insert Likes"
ON public.likes FOR INSERT
TO anon, authenticated
WITH CHECK (true);

DROP POLICY IF EXISTS "Public Delete Likes" ON public.likes;
CREATE POLICY "Public Delete Likes"
ON public.likes FOR DELETE
TO anon, authenticated
USING (true);

-- ==========================================
-- 19. POLITIQUES RLS POUR REACTIONS
-- ==========================================

DROP POLICY IF EXISTS "Public Read Reactions" ON public.reactions;
CREATE POLICY "Public Read Reactions"
ON public.reactions FOR SELECT
TO anon, authenticated
USING (true);

DROP POLICY IF EXISTS "Public Insert Reactions" ON public.reactions;
CREATE POLICY "Public Insert Reactions"
ON public.reactions FOR INSERT
TO anon, authenticated
WITH CHECK (true);

DROP POLICY IF EXISTS "Public Update Reactions" ON public.reactions;
CREATE POLICY "Public Update Reactions"
ON public.reactions FOR UPDATE
TO anon, authenticated
USING (true);

DROP POLICY IF EXISTS "Public Delete Reactions" ON public.reactions;
CREATE POLICY "Public Delete Reactions"
ON public.reactions FOR DELETE
TO anon, authenticated
USING (true);

-- ==========================================
-- 20. POLITIQUES RLS POUR GUESTS
-- ==========================================

DROP POLICY IF EXISTS "Public Read Guests" ON public.guests;
DROP POLICY IF EXISTS "Public Read Guests By Event" ON public.guests;
CREATE POLICY "Public Read Guests By Event"
ON public.guests FOR SELECT
TO anon, authenticated
USING (
    event_id IS NOT NULL AND
    EXISTS (SELECT 1 FROM public.events WHERE events.id = guests.event_id AND events.is_active = true)
);

DROP POLICY IF EXISTS "Public Insert Guests" ON public.guests;
DROP POLICY IF EXISTS "Public Insert Guests By Event" ON public.guests;
CREATE POLICY "Public Insert Guests By Event"
ON public.guests FOR INSERT
TO anon, authenticated
WITH CHECK (
    event_id IS NOT NULL AND
    EXISTS (SELECT 1 FROM public.events WHERE events.id = guests.event_id AND events.is_active = true)
);

DROP POLICY IF EXISTS "Authenticated Update Guests" ON public.guests;
CREATE POLICY "Authenticated Update Guests"
ON public.guests FOR UPDATE
TO authenticated
USING (true)
WITH CHECK (true);

DROP POLICY IF EXISTS "Authenticated Delete Guests" ON public.guests;
CREATE POLICY "Authenticated Delete Guests"
ON public.guests FOR DELETE
TO authenticated
USING (true);

-- ==========================================
-- 21. POLITIQUES RLS POUR BLOCKED_GUESTS
-- ==========================================

DROP POLICY IF EXISTS "Public Read Blocked Guests" ON public.blocked_guests;
DROP POLICY IF EXISTS "Public Read Blocked Guests By Event" ON public.blocked_guests;
CREATE POLICY "Public Read Blocked Guests By Event"
ON public.blocked_guests FOR SELECT
TO anon, authenticated
USING (
    event_id IS NOT NULL AND
    EXISTS (SELECT 1 FROM public.events WHERE events.id = blocked_guests.event_id AND events.is_active = true)
);

DROP POLICY IF EXISTS "Authenticated Insert Blocked Guests" ON public.blocked_guests;
DROP POLICY IF EXISTS "Organizers Insert Blocked Guests By Event" ON public.blocked_guests;
CREATE POLICY "Organizers Insert Blocked Guests By Event"
ON public.blocked_guests FOR INSERT
TO authenticated
WITH CHECK (
    event_id IS NOT NULL AND
    public.is_event_organizer(blocked_guests.event_id, auth.uid())
);

DROP POLICY IF EXISTS "Authenticated Delete Blocked Guests" ON public.blocked_guests;
CREATE POLICY "Authenticated Delete Blocked Guests"
ON public.blocked_guests FOR DELETE
TO authenticated
USING (true);

-- ==========================================
-- 22. POLITIQUES RLS POUR PHOTO_BATTLES
-- ==========================================

DROP POLICY IF EXISTS "Public Read Battles" ON public.photo_battles;
DROP POLICY IF EXISTS "Public Read Battles By Event" ON public.photo_battles;
CREATE POLICY "Public Read Battles By Event"
ON public.photo_battles FOR SELECT
TO anon, authenticated
USING (
    event_id IS NOT NULL AND
    EXISTS (SELECT 1 FROM public.events WHERE events.id = photo_battles.event_id AND events.is_active = true)
);

DROP POLICY IF EXISTS "Public Insert Battles" ON public.photo_battles;
DROP POLICY IF EXISTS "Public Insert Battles By Event" ON public.photo_battles;
CREATE POLICY "Public Insert Battles By Event"
ON public.photo_battles FOR INSERT
TO anon, authenticated
WITH CHECK (
    event_id IS NOT NULL AND
    EXISTS (SELECT 1 FROM public.events WHERE events.id = photo_battles.event_id AND events.is_active = true)
);

DROP POLICY IF EXISTS "Public Update Battles" ON public.photo_battles;
CREATE POLICY "Public Update Battles"
ON public.photo_battles FOR UPDATE
TO anon, authenticated
USING (true);

-- ==========================================
-- 23. POLITIQUES RLS POUR BATTLE_VOTES
-- ==========================================

DROP POLICY IF EXISTS "Public Read Battle Votes" ON public.battle_votes;
CREATE POLICY "Public Read Battle Votes"
ON public.battle_votes FOR SELECT
TO anon, authenticated
USING (true);

DROP POLICY IF EXISTS "Public Insert Battle Votes" ON public.battle_votes;
CREATE POLICY "Public Insert Battle Votes"
ON public.battle_votes FOR INSERT
TO anon, authenticated
WITH CHECK (true);

-- ==========================================
-- 24. TRIGGERS ET FONCTIONS
-- ==========================================

-- Fonction pour mettre à jour updated_at sur reactions
CREATE OR REPLACE FUNCTION update_reactions_updated_at()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = now();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS reactions_updated_at_trigger ON public.reactions;
CREATE TRIGGER reactions_updated_at_trigger
BEFORE UPDATE ON public.reactions
FOR EACH ROW
EXECUTE FUNCTION update_reactions_updated_at();

-- Fonction pour compter les réactions par type
CREATE OR REPLACE FUNCTION get_photo_reactions(photo_uuid UUID)
RETURNS JSONB AS $$
BEGIN
    RETURN (
        SELECT jsonb_object_agg(
            reaction_type,
            count
        )
        FROM (
            SELECT 
                reaction_type,
                count(*)::int AS count
            FROM public.reactions
            WHERE photo_id = photo_uuid
            GROUP BY reaction_type
        ) AS counts
    );
END;
$$ LANGUAGE plpgsql;

-- Fonction trigger pour mettre à jour likes_count
CREATE OR REPLACE FUNCTION update_photo_likes_count()
RETURNS TRIGGER AS $$
BEGIN
    IF TG_OP = 'INSERT' THEN
        UPDATE public.photos 
        SET likes_count = likes_count + 1 
        WHERE id = NEW.photo_id;
        RETURN NEW;
    ELSIF TG_OP = 'DELETE' THEN
        UPDATE public.photos 
        SET likes_count = GREATEST(0, likes_count - 1) 
        WHERE id = OLD.photo_id;
        RETURN OLD;
    END IF;
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS likes_count_trigger ON public.likes;
CREATE TRIGGER likes_count_trigger
AFTER INSERT OR DELETE ON public.likes
FOR EACH ROW
EXECUTE FUNCTION update_photo_likes_count();

-- Fonction trigger pour mettre à jour battle votes count
CREATE OR REPLACE FUNCTION update_battle_votes_count()
RETURNS TRIGGER AS $$
BEGIN
    IF TG_OP = 'INSERT' THEN
        IF NEW.voted_for_photo_id = (
            SELECT photo1_id FROM public.photo_battles WHERE id = NEW.battle_id
        ) THEN
            UPDATE public.photo_battles
            SET votes1_count = votes1_count + 1
            WHERE id = NEW.battle_id;
        ELSIF NEW.voted_for_photo_id = (
            SELECT photo2_id FROM public.photo_battles WHERE id = NEW.battle_id
        ) THEN
            UPDATE public.photo_battles
            SET votes2_count = votes2_count + 1
            WHERE id = NEW.battle_id;
        END IF;
        RETURN NEW;
    ELSIF TG_OP = 'DELETE' THEN
        IF OLD.voted_for_photo_id = (
            SELECT photo1_id FROM public.photo_battles WHERE id = OLD.battle_id
        ) THEN
            UPDATE public.photo_battles
            SET votes1_count = GREATEST(0, votes1_count - 1)
            WHERE id = OLD.battle_id;
        ELSIF OLD.voted_for_photo_id = (
            SELECT photo2_id FROM public.photo_battles WHERE id = OLD.battle_id
        ) THEN
            UPDATE public.photo_battles
            SET votes2_count = GREATEST(0, votes2_count - 1)
            WHERE id = OLD.battle_id;
        END IF;
        RETURN OLD;
    END IF;
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS battle_votes_count_trigger ON public.battle_votes;
CREATE TRIGGER battle_votes_count_trigger
AFTER INSERT OR DELETE ON public.battle_votes
FOR EACH ROW
EXECUTE FUNCTION update_battle_votes_count();

-- Fonction pour terminer automatiquement une battle expirée
CREATE OR REPLACE FUNCTION finish_battle_if_expired()
RETURNS void AS $$
BEGIN
    UPDATE public.photo_battles
    SET 
        status = 'finished',
        winner_id = CASE
            WHEN votes1_count > votes2_count THEN photo1_id
            WHEN votes2_count > votes1_count THEN photo2_id
            ELSE NULL
        END,
        finished_at = now()
    WHERE 
        status = 'active'
        AND expires_at IS NOT NULL
        AND expires_at < now();
END;
$$ LANGUAGE plpgsql;

-- Fonction pour nettoyer les blocages expirés
CREATE OR REPLACE FUNCTION cleanup_expired_blocks()
RETURNS void AS $$
BEGIN
    DELETE FROM public.blocked_guests
    WHERE expires_at < now();
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Synchronisation initiale du compteur likes_count
UPDATE public.photos p
SET likes_count = (
    SELECT COUNT(*) 
    FROM public.likes l 
    WHERE l.photo_id = p.id
);

-- ==========================================
-- 25. REALTIME PUBLICATIONS
-- ==========================================

DO $$
BEGIN
    -- Photos
    BEGIN
        ALTER PUBLICATION supabase_realtime ADD TABLE public.photos;
    EXCEPTION
        WHEN duplicate_object THEN NULL;
    END;

    -- Likes
    BEGIN
        ALTER PUBLICATION supabase_realtime ADD TABLE public.likes;
    EXCEPTION
        WHEN duplicate_object THEN NULL;
    END;

    -- Reactions
    BEGIN
        ALTER PUBLICATION supabase_realtime ADD TABLE public.reactions;
    EXCEPTION
        WHEN duplicate_object THEN NULL;
    END;

    -- Guests
    BEGIN
        ALTER PUBLICATION supabase_realtime ADD TABLE public.guests;
    EXCEPTION
        WHEN duplicate_object THEN NULL;
    END;

    -- Photo Battles
    BEGIN
        ALTER PUBLICATION supabase_realtime ADD TABLE public.photo_battles;
    EXCEPTION
        WHEN duplicate_object THEN NULL;
    END;

    -- Battle Votes
    BEGIN
        ALTER PUBLICATION supabase_realtime ADD TABLE public.battle_votes;
    EXCEPTION
        WHEN duplicate_object THEN NULL;
    END;

    -- Event Settings
    BEGIN
        ALTER PUBLICATION supabase_realtime ADD TABLE public.event_settings;
    EXCEPTION
        WHEN duplicate_object THEN NULL;
    END;

    -- Events
    BEGIN
        ALTER PUBLICATION supabase_realtime ADD TABLE public.events;
    EXCEPTION
        WHEN duplicate_object THEN NULL;
    END;

    -- Event Organizers
    BEGIN
        ALTER PUBLICATION supabase_realtime ADD TABLE public.event_organizers;
    EXCEPTION
        WHEN duplicate_object THEN NULL;
    END;
END $$;

-- ==========================================
-- 26. GRANT PERMISSIONS
-- ==========================================

GRANT SELECT, INSERT, UPDATE, DELETE ON public.events TO authenticated;
GRANT SELECT, INSERT, UPDATE, DELETE ON public.event_organizers TO authenticated;
GRANT SELECT, INSERT, UPDATE, DELETE ON public.photos TO authenticated;
GRANT SELECT, INSERT, UPDATE, DELETE ON public.event_settings TO authenticated;
GRANT SELECT, INSERT, UPDATE, DELETE ON public.likes TO authenticated;
GRANT SELECT, INSERT, UPDATE, DELETE ON public.reactions TO authenticated;
GRANT SELECT, INSERT, UPDATE, DELETE ON public.guests TO authenticated;
GRANT SELECT, INSERT, UPDATE, DELETE ON public.blocked_guests TO authenticated;
GRANT SELECT, INSERT, UPDATE, DELETE ON public.photo_battles TO authenticated;
GRANT SELECT, INSERT, UPDATE, DELETE ON public.battle_votes TO authenticated;

-- ==========================================
-- FIN DU SETUP COMPLET
-- ==========================================
-- 
-- Le setup est maintenant complet. Toutes les tables,
-- politiques, triggers et fonctions sont en place.
--
-- Pour créer un utilisateur admin :
-- 1. Allez dans Supabase Dashboard > Authentication > Users
-- 2. Cliquez sur "Invite user" ou créez un utilisateur manuellement
-- 3. Utilisez ces identifiants pour vous connecter
-- 4. (Optionnel) Désactivez l'inscription publique dans Authentication > Settings
--
-- Architecture SaaS multi-événements :
-- - Chaque événement a son propre slug unique
-- - Toutes les données sont isolées par event_id
-- - Les organisateurs peuvent gérer plusieurs événements
-- - RLS garantit l'isolation des données entre événements
--
-- ==========================================

